<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Subliminal</title>
    <style>
      html {
        height: 100%;
        cursor: crosshair;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: row;
        min-height: 100%;
        margin: 0;
      }

      #sillaba {
        font-family: courier, monospace;
        font-size: min(50vw, 100vh);
        transform: translateY(-15%);
        line-height: 1.2;
      }
    </style>
  </head>
  <body>
    <div id="sillaba"></div>
    <script>
      const sillaba = document.getElementById('sillaba');
      const sillabe = ['ba', 'bo', 'bi', 'bu', 'be', 'ca', 'co', 'ci', 'cu', 'ce', 'da', 'do', 'di', 'du', 'de', 'ta', 'to', 'ti', 'tu', 'te', 'fa', 'fo', 'fi', 'fu', 'fe', 'ga', 'go', 'gi', 'gu', 'ge', 'pa', 'po', 'pi', 'pu', 'pe', 'ra', 'ro', 'ri', 'ru', 're', 'la', 'lo', 'li', 'lu', 'le', 'za', 'zo', 'zi', 'zu', 'ze', 'bar', 'bir', 'bur'];
      const parole = [
        ['ge', 'la', 'to', 'al', 'la', 'man', 'dor', 'la'],
        ['ma', 'ri', 'ua', 'na'],
      ];
      let cycle = 50;
      let duty = 33;
      let rafThen = 0;
      let idx = 0;
      let subliminal = false;
      let probability = 0.02;
      let step = false;
      let rafID;

      const raf = (rafNow) => {
        const elapsed = rafNow - rafThen;

        if (elapsed > cycle) {
          // sillaba.style.color = subliminal ? 'red' : 'black';
          sillaba.innerHTML = (subliminal ? parole[subliminal - 1][idx] : sillabe[idx]) || '';
          step = true;
          rafThen = rafNow;
        } else if (elapsed > duty) {
          sillaba.innerHTML = '';
        }

        if (step) {
          step = false;
          subliminal = subliminal && (idx + 1) < parole[subliminal - 1].length && subliminal;

          if (subliminal) {
            idx++;
          } else {
            const rand = Math.random();
            subliminal = rand < probability ? Math.ceil(Math.random() * parole.length) : false;
            idx = subliminal ? 0 : Math.floor(rand * sillabe.length);
          }
        }

        rafID = requestAnimationFrame(raf);
      };

      raf();
      

      
      let slow = false;
      const invert = () => {
        slow = !slow;
        if (slow) {
          document.documentElement.style.background = 'black';
          document.documentElement.style.color = 'white';
          probability = 0.1;
        } else {
          document.documentElement.style.background = 'white';
          document.documentElement.style.color = 'black';
          probability = 0.02;
        }
      };

      let mousedown = false;
      let dragging = false;
      if (window.matchMedia("(hover: hover)").matches) {
        document.addEventListener('mousedown', () => { mousedown = true; });
        document.addEventListener('mouseup', () => {
          mousedown = false;
          if (dragging) {
            dragging = false;
          } else {        
            invert();
          }
        });
        document.addEventListener('mousemove', (e) => {
          if (mousedown) {
            e.preventDefault();
            e.stopImmediatePropagation();
            dragging = true;
            const u = e.clientX / document.documentElement.clientWidth;
            const v = e.clientY / document.documentElement.clientHeight;
            cycle = Math.ceil(500 * (1 - u));
            duty = Math.ceil(cycle * (1 - v));
          }
        });
      } else {
        document.addEventListener('touchend', () => {
          if (dragging) {
            dragging = false;
          } else {        
            invert();
          }
        });
        document.addEventListener('touchmove', (e) => {
          e.preventDefault();
          e.stopImmediatePropagation();
          dragging = true;
          const touches = [];
          for (let i = 0; i < e.targetTouches.length; i++) {
            const u = e.targetTouches.item(i).clientX / document.documentElement.clientWidth;
            const v = e.targetTouches.item(i).clientY / document.documentElement.clientHeight;
            touches.push({u, v});
          }
          if (touches.length > 1) {
            touches.sort((a, b) => (a.u - b.u));
            cycle = Math.ceil(500 * touches[1].v);
            duty = Math.ceil(cycle * touches[0].v);
          } else {
            if (touches[0].u < 0.5) {
              duty = Math.ceil(cycle * touches[0].v);
            } else {
              cycle = Math.ceil(500 * touches[0].v);
            }
          }
        }, { passive: false });
      }
    </script>
  </body>
</html>
